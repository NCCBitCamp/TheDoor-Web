<!DOCTYPE html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>ì—˜ë ˆë² ì´í„° ìˆ˜ë¦¬</title>
  <meta name="author" content="Lewis Nakao">
  <meta name="description" content="The Fixing Wiring mini game from Among Us written in JavaScript canvas">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="ğŸ›°ï¸ Fix Wiring Among Us game">
  <meta name="twitter:description" content="The Fixing Wiring mini game from Among Us written in JavaScript canvas">
  <meta name="twitter:site" content="@lewdev">
  <meta name="twitter:creator" content="@lewdev">
  <meta name="twitter:image" content="">

  <!-- Open Graph general (Facebook, Pinterest)-->
  <meta property="og:title" content="ğŸ›°ï¸ Fix Wiring Among Us game">
  <meta property="og:description" content="The Fixing Wiring mini game from Among Us written in JavaScript canvas">
  <meta property="og:url" content="https://lewdev.github.io/apps/fix-wires-js">
  <meta property="og:site_name" content="lewdev.github.io">
  <meta property="og:type" content="website">
  <meta property="og:image" content="">

  <!-- Emoji SVG favicon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ›°ï¸</text></svg>">

  <style>
    html, body {
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      margin: 0;
    }

    #canvas {
      background: white;
      max-height: 100%;
      max-width: 100%;
    }

    #sourceBtn {
      position: fixed;
      top: 0;
      right: 0;
      width: 8rem;
      background-color: #CCC;
    }
  </style>
</head>
<body>
  <div id="sourceBtn">
    <a href="https://github.com/lewdev/fix-wires-js" target="_blank" title="Source code">ğŸ‘¨ğŸ»â€ğŸ’» Source Code</a>
  </div>

  <canvas id="canvas" width="1920" height="1080"></canvas>
  <script>
    const context = canvas.getContext('2d');
    const W = 1920;
    const T = 1080;
    const colors = ["red", "#0F0", "#00F", "#FF0", "#F0F"];
    const letters = "     ";
    let completedMatches = [];
    let shuffledColors = [];
    let isDone = false;
    let startX, startY;
    let selectedIndex = -1;
    let lastCheckTime = 0;
    const checkInterval = 1000; // 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ì²´í¬

    // ìº”ë²„ìŠ¤ í¬ê¸° ì¬ì„¤ì •
    const setBoundingRect = () => canvasRect = canvas.getBoundingClientRect();
    addEventListener("resize", setBoundingRect);
    addEventListener("scroll", setBoundingRect);
    setBoundingRect();

    // ë°°ì—´ ì„ê¸°
    const shuffleArray = (array) => {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    };

    // ì„  ê·¸ë¦¬ê¸°
    const drawLine = (color, x1, y1, x2, y2, lineWidth = 20) => {
      if (lineWidth === 20) drawLine("#000", x1, y1, x2, y2, 25);
      context.strokeStyle = color;
      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      context.lineWidth = lineWidth;
      context.stroke();
    };

    // ì‚¬ê°í˜• ê·¸ë¦¬ê¸°
    const drawRect = (color, x, y, width, height) => {
      if (color !== "#000") drawRect("#000", x - 5, y - 5, width + 10, height + 10);
      context.fillStyle = color;
      context.fillRect(x, y, width, height);
    };

    // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
    const drawText = (text, x, y, fontSize = '1in') => {
      context.font = fontSize;
      context.fillStyle = "#000";
      context.fillText(text, x, y);
    };

    // ê²Œì„ ì´ˆê¸°í™”
    const initializeGame = () => {
      completedMatches = [];
      shuffledColors = shuffleArray([...colors]);
    };

    // ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì—…ë°ì´íŠ¸
    const updateMouseCoordinates = (clientX, clientY) => {
      const { left, top, width, height } = canvasRect;
      startX = (clientX - left) * W / width;
      startY = (clientY - top) * T / height;
    };

    // ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸
    canvas.onmousemove = (e) => updateMouseCoordinates(e.clientX, e.clientY);

    // ë§ˆìš°ìŠ¤ ë‹¤ìš´ ì´ë²¤íŠ¸ ì²˜ë¦¬
    const handleMouseDown = () => {
      if (isDone) {
        initializeGame();
      } else if (startX < 216 && !completedMatches[selectedIndex = Math.floor(startY / 216)]) {
        selectedIndex = Math.floor(startY / 216);
      }
    };

    let alertTriggered = false; // í”Œë˜ê·¸ ì¶”ê°€

    // ë§ˆìš°ìŠ¤ ì—… ì´ë²¤íŠ¸ ì²˜ë¦¬
    const handleMouseUp = () => {
      if (startX > W - 216 && shuffledColors[Math.floor(startY / 216)] === colors[selectedIndex]) {
        completedMatches[selectedIndex] = 1;
        selectedIndex = -1;
      } else {
        selectedIndex = -1;
      }
    };

    let touchStartTimeout1 = null;
    let touchStartTimeout2 = null;

    // í„°ì¹˜ ì‹œì‘ ì´ë²¤íŠ¸ ì²˜ë¦¬
    const handleTouchStart = (e) => {
      const touch = e.changedTouches[0];
      updateMouseCoordinates(touch.clientX, touch.clientY);
      if (!touchStartTimeout1) {
        handleMouseDown();
        touchStartTimeout1 = setTimeout(() => touchStartTimeout1 = null, 300);
      }
    };

    // í„°ì¹˜ ì¢…ë£Œ ì´ë²¤íŠ¸ ì²˜ë¦¬
    const handleTouchEnd = (e) => {
      const touch = e.changedTouches[0];
      updateMouseCoordinates(touch.clientX, touch.clientY);
      if (!touchStartTimeout2) {
        handleMouseUp();
        touchStartTimeout2 = setTimeout(() => touchStartTimeout2 = null, 300);
      }
    };

    canvas.onmousedown = handleMouseDown;
    canvas.onmouseup = handleMouseUp;
    canvas.addEventListener("touchstart", handleTouchStart);
    canvas.addEventListener("touchend", handleTouchEnd);
    canvas.addEventListener("touchmove", (e) => {
      const touch = e.changedTouches[0];
      updateMouseCoordinates(touch.clientX, touch.clientY);
    });

    // ê²Œì„ í™”ë©´ ê·¸ë¦¬ê¸°
    const drawGame = () => {
      context.clearRect(0, 0, W, T);
      drawRect("#888", 0, 0, W, T);

      // ì˜¤ë¥¸ìª½ ì‚¬ê°í˜• ê·¸ë¦¬ê¸°
      shuffledColors.forEach((color, i) => drawRect(color, W - 216, i * 216, 216, 216));

      // ì™¼ìª½ ì‚¬ê°í˜• ë° ì™„ë£Œëœ ì„  ê·¸ë¦¬ê¸°
      colors.forEach((color, i) => {
        drawRect(color, 0, i * 216, 216, 216);
        if (completedMatches[i]) {
          drawLine(color, 108, i * 216 + 108, W - 108, shuffledColors.indexOf(color) * 216 + 108);
        }
        drawText(letters[i], 54, i * 216 + 108 + 20);
        drawText(letters[i], W - 162, shuffledColors.indexOf(color) * 216 + 108 + 20);
      });

      // í´ë¦­ëœ ì„  ê·¸ë¦¬ê¸°
      if (selectedIndex > -1) {
        drawLine(colors[selectedIndex], 108, selectedIndex * 216 + 108, startX, startY);
      }

      // ì™„ë£Œ ìƒíƒœ ì²´í¬ ë° ê²½ê³  ë©”ì‹œì§€
      if (completedMatches.filter(Boolean).length === colors.length && !alertTriggered) {
          isDone = true;
          alertTriggered = true; // í”Œë˜ê·¸ ì„¤ì •
          localStorage.setItem('elevatorRepairCompleted', 'true'); // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì™„ë£Œ ìƒíƒœ ì €ì¥
          alert("ì—˜ë¦¬ë² ì´í„° ìˆ˜ë¦¬ë¥¼ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤!");
          window.location.href = '101Room.html';
      }
    };

    // ê²Œì„ ë£¨í”„
    const gameLoop = () => {
      requestAnimationFrame(gameLoop);
      drawGame();
    };

    initializeGame();
    gameLoop();
  </script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GNP8ER8985"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-GNP8ER8985');
  </script>
</body>
</html>
